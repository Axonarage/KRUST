use core::sync::atomic::{compiler_fence, Ordering};
use cortex_m_semihosting::hprintln;

#[unsafe(no_mangle)]
pub unsafe extern "C" fn DefaultHandler() -> ! {
    loop {
        hprintln!("Handler").ok();
        compiler_fence(Ordering::SeqCst);
    }
}

#[unsafe(no_mangle)]
pub unsafe extern "C" fn HardFaultHandler() -> ! {

    /*
        Hard Fault stats Register

        Address offset : 0x2C
    
        Bit 31    : DEBUG_VT : Reserved for Debug use. When writing to the register you must write 0 to this bit, otherwise behavior is unpredictable.
        Bit 30    : FORCED   : Forced hard fault. Indicates a forced hard fault, generated by escalation of a fault with configurable priority that cannot 
                               be handles, either because of priority or because it is disabled.
                               When this bit is set to 1, the hard fault handler must read the other fault status registers to find the cause of the fault.
        Bits 29:2 : Reserved
        Bit 1     : VECTTBL  : Vector table hard fault. Indicates a bus fault on a vector table read during exception processing. This error is always handled 
                               by the hard fault handler.
                               When this bit is set to 1, the PC value stacked for the exception return points to the instruction that was preempted by the exception.
        Bit 0     : Reserved

        https://developer.arm.com/documentation/dui0552/a/cortex-m3-peripherals/system-control-block/hardfault-status-register - Section 4.4.14
     */
    const HFSR_ADDR: u32 = 0xE000ED2C;

    unsafe {
        // Read the value from the HFSR address
        let hfsr_value: u32 = core::ptr::read_volatile(HFSR_ADDR as *const u32);

        let debug_vt = (hfsr_value >> 31) & 1;
        let forced = (hfsr_value >> 30) & 1;
        let vecttbl = (hfsr_value >> 1) & 1;

        if debug_vt == 1 {
            debug_log(format_args!("Debug is used."))
        }
        if forced == 1 {
            // inspect other fault status registers
            debug_log(format_args!("Forced hard fault. Need to inspect the other fault status registers."));
            // TO DO
            // INSPECT
            ConfigurableFaultHandler();  
        }
        if vecttbl == 1 {
            debug_log(format_args!("Bus fault while trying to read the vector table."));
            //asm!(
            //    "BKPT #0"
            //);
        }

        // Keep the program in an infinite loop
        loop {
            core::sync::atomic::compiler_fence(core::sync::atomic::Ordering::SeqCst);
        }
    }
}


#[unsafe(no_mangle)]
pub unsafe extern "C" fn ConfigurableFaultHandler() -> ! {
    /*
        Configurable Fault Status Register

        Address offset : 0x28
    
        Usage Fault Status Register

        Bits 31:26 : Reserved   :
        Bit 25     : DIVBYZERO  : Divide by zero usage fault. When the processor sets this bit to 1, the PC value stacked for the exception return points to 
                                  the instruction that performed the divide by zero.
        Bit 24     : UNALIGNED  : Unaligned access usage fault. Enable trapping of unaligned accesses by setting the UNALIGN_TRP bit in the CCR to 1.
        Bits 23:20 : Reserved
        Bit 19     : NOCP       : No coprocessor usage fault. The processor does not support coprocessor instructions.
        Bit 18     : INVPC      : Invalid PC load usage fault, caused by an invalid PC load by EXC_RETURN. When this bit is set to 1, the PC value stacked for 
                                  the exception return points to the instruction that tried to perform the illegal load of the PC.
        Bit 17     : INVSTATE   : Invalid state usage fault. When this bit is set to 1, the PC value stacked for the exception return points to the instruction 
                                  that attempted the illegal use of the EPSR. This bit is not set to 1 if an undefined instruction uses the EPSR.
        Bit 16     : UNDEFINSTR : Undefined instruction usage fault. When this bit is set to 1, the PC value stacked for the exception return points to the 
                                  undefined instruction. An undefined instruction is an instruction that the processor cannot decode.

        Bus Fault Status Register

        Bit 15     : BFARVALID  : Bus Fault Address Register (BFAR) valid flag. The processor sets this bit to 1 after a bus fault where the address is known. 
                                  Other faults can set this bit to 0, such as a memory management fault occurring later. If a bus fault occurs and is escalated 
                                  to a hard fault because of priority, the hard fault handler must set this bit to 0. This prevents problems if returning to a 
                                  stacked active bus fault handler whose BFAR value is overwritten.
        Bit 14     : Reserved
        Bit 13     : LSPERR     : Bus fault on floating-point lazy state preservation.
        Bit 12     : STKERR     : Bus fault on stacking for exception entry. When the processor sets this bit to 1, the SP is still adjusted but the values in 
                                  the context area on the stack might be incorrect. The processor does not write a fault address to the BFAR.
        Bit 11     : UNSTKERR   : Bus fault on unstacking for a return from exception. This fault is chained to the handler. This means that when the processor 
                                  sets this bit to 1, the original return stack is still present. The processor does not adjust the SP from the failing return, 
                                  does not performed a new save, and does not write a fault address to the BFAR.
        Bit 10     : IMPRECISERR: Imprecise data bus error. When the processor sets this bit to 1, it does not write a fault address to the BFAR. This is an 
                                  asynchronous fault. Therefore, if it is detected when the priority of the current process is higher than the bus fault priority, 
                                  the bus fault becomes pending and becomes active only when the processor returns from all higher priority processes. If a precise 
                                  fault occurs before the processor enters the handler for the imprecise bus fault, the handler detects both IMPRECISERR set to 1 
                                  and one of the precise fault status bits set to 1.
        Bit 9      : PRECISERR  : Precise data bus error. When the processor sets this bit is 1, it writes the faulting address to the BFAR.
        Bit 8      : IBUSERR    : Instruction bus error. The processor detects the instruction bus error on prefetching an instruction, but it sets the IBUSERR 
                                  flag to 1 only if it attempts to issue the faulting instruction.
        
        Memory Management Fault Status Address Register

        Bit 7      : MMARVALID  : Memory Management Fault Address Register (MMAR) valid flag. If a memory management fault occurs and is escalated to a hard fault 
                                  because of priority, the hard fault handler must set this bit to 0. This prevents problems on return to a stacked active memory 
                                  management fault handler whose MMAR value is overwritten.
        Bit 6      : Reserved 
        Bit 5      : MLSPERR    : A MemManage fault occurred during floating-point lazy state preservation. 
        Bit 4      : MSTKERR    : Memory manager fault on stacking for exception entry. When this bit is 1, the SP is still adjusted but the values in the context 
                                  area on the stack might be incorrect. The processor has not written a fault address to the MMAR.
        Bit 3      : MUNSTKERR  : Memory manager fault on unstacking for a return from exception. This fault is chained to the handler. This means that when this 
                                  bit is 1, the original return stack is still present. The processor has not adjusted the SP from the failing return, and has not 
                                  performed a new save. The processor has not written a fault address to the MMAR.
        Bit 2      : Reserved
        Bit 1      : DACCVIOL   : Data access violation flag. When this bit is 1, the PC value stacked for the exception return points to the faulting instruction. 
                                  The processor has loaded the MMAR with the address of the attempted access.
        Bit 0      : IACCVIOL   : Instruction access violation flag. This fault occurs on any access to an XN region, even the MPU is disabled or not present. When 
                                  this bit is 1, the PC value stacked for the exception return points to the faulting instruction. The processor has not written a 
                                  fault address to the MMAR.

        https://developer.arm.com/documentation/dui0552/a/cortex-m3-peripherals/system-control-block/hardfault-status-register - Section 4.4.10
     */
    const CFSR_ADDR: u32 = 0xE000ED28;
    
    unsafe{
        let cfsr_value: u32 = core::ptr::read_volatile(CFSR_ADDR as *const u32);

        // UFSR : Usage Fault status register
        let divbyzero = (cfsr_value >> 25) & 1;
        let unaligned = (cfsr_value >> 24) & 1;
        let nocp = (cfsr_value >> 19) & 1;
        let invpc = (cfsr_value >> 18) & 1;
        let invstate = (cfsr_value >> 17) & 1;
        let undefinstr = (cfsr_value >> 16) & 1;

        // BFSR : Bus Fault status register
        let bfarvalid = (cfsr_value >> 15) & 1;
        let lsperr = (cfsr_value >> 13) & 1;
        let stkerr = (cfsr_value >> 12) & 1;
        let unstkerr = (cfsr_value >> 11) & 1;
        let impreciserr = (cfsr_value >> 10) & 1;
        let preciserr = (cfsr_value >> 9) & 1;
        let ibuserr = (cfsr_value >> 8) & 1;

        // MMFSR : Memory Management Fault status address register
        let mmarvalid = (cfsr_value >> 7) & 1;
        let mlsperr = (cfsr_value >> 5) & 1;
        let mstkerr = (cfsr_value >> 4) & 1;
        let munstkerr = (cfsr_value >> 3) & 1;
        let daccviol = (cfsr_value >> 1) & 1;
        let iaccviol = (cfsr_value >> 0) & 1;

        if divbyzero == 1 || unaligned == 1 || nocp == 1 || invpc == 1 || invstate == 1 || undefinstr == 1 {
            debug_log(format_args!("Usage Fault."));
            
            if divbyzero == 1 {
                debug_log(format_args!("Divide by zero usage fault."));
            }
            if unaligned == 1 {
                debug_log(format_args!("Unaligned access usage fault."));
            }
            if nocp == 1 {
                debug_log(format_args!("No coprocessor usage fault."));
            }
            if invpc == 1 {
                debug_log(format_args!("Invalid PC load usage fault, caused by an invalid PC load by EXC_RETURN."));
            }
            if invstate == 1 {
                debug_log(format_args!("Invalid state usage fault."));
            }
            if undefinstr == 1 {
                debug_log(format_args!("Undefined instruction usage fault."));
            }
        }

        if bfarvalid == 1 || lsperr == 1 || stkerr == 1 || unstkerr == 1 || impreciserr == 1 || preciserr == 1 || ibuserr == 1 {
            debug_log(format_args!("Bus Fault."));

            if bfarvalid == 1 {
                debug_log(format_args!("Bus Fault Address Register (BFAR) valid flag."));
            }
            if lsperr == 1 {
                debug_log(format_args!("Bus fault on floating-point lazy state preservation."));
            }
            if stkerr == 1 {
                debug_log(format_args!("Bus fault on stacking for exception entry."));
            }
            if unstkerr == 1 {
                debug_log(format_args!("Bus fault on unstacking for a return from exception."));
            }
            if impreciserr == 1 {
                debug_log(format_args!("Imprecise data bus error."));
            }
            if preciserr == 1 {
                debug_log(format_args!("Precise data bus error."));
            }
            if ibuserr == 1 {
                debug_log(format_args!("Instruction bus error."));
            }
        }

        if mmarvalid == 1 || mlsperr == 1 || mstkerr == 1 || munstkerr == 1 || daccviol == 1 || iaccviol == 1 {
            debug_log(format_args!("Memory Management Fault."));
            
            if mmarvalid == 1 {
                debug_log(format_args!("Memory Management Fault Address Register (MMAR) valid flag."));
            }
            if mlsperr == 1 {
                debug_log(format_args!("MemManage fault occurred during floating-point lazy state preservation."));
            }
            if mstkerr == 1 {
                debug_log(format_args!("Memory manager fault on stacking for exception entry."));
            }
            if munstkerr == 1 {
                debug_log(format_args!("Memory manager fault on unstacking for a return from exception."));
            }
            if daccviol == 1 {
                debug_log(format_args!("Data access violation flag."));
            }
            if iaccviol == 1 {
                debug_log(format_args!("Instruction access violation flag."));
            }
        }
    }

    loop {
        // Optional: You could trigger a breakpoint for debugging here
        core::sync::atomic::compiler_fence(core::sync::atomic::Ordering::SeqCst);
    }
}

fn debug_log(args: core::fmt::Arguments) {
    // cortex-m-semihosting logging
    hprintln!("{}", args).ok();
}